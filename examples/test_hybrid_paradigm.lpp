#pragma paradigm hybrid

// This file demonstrates hybrid paradigm - mix of all styles

fn double(x: int) -> int {
    return x * 2;
}

fn triple(x: int) -> int {
    return x * 3;
}

fn imperative_sum() -> int {
    let mut sum = 0;
    let mut i = 1;
    
    while (i <= 5) {
        sum = sum + i;
        i = i + 1;
    }
    
    return sum;
}

fn functional_factorial(n: int) -> int {
    if (n <= 1) {
        return 1;
    }
    return n * functional_factorial(n - 1);
}

fn main() -> int {
    // Imperative style
    let total = imperative_sum();
    
    // Functional style (recursion)
    let fact = functional_factorial(5);
    
    // Mix of styles
    let doubled = double(total);
    let tripled = triple(fact);
    
    return 0;
}
